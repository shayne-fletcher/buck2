"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[5827],{3905:(e,n,t)=>{t.r(n),t.d(n,{MDXContext:()=>u,MDXProvider:()=>c,mdx:()=>x,useMDXComponents:()=>p,withMDXComponents:()=>d});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(){return i=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e},i.apply(this,arguments)}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var u=a.createContext({}),d=function(e){return function(n){var t=p(n.components);return a.createElement(e,i({},n,{components:t}))}},p=function(e){var n=a.useContext(u),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},c=function(e){var n=p(e.components);return a.createElement(u.Provider,{value:n},e.children)},m="mdxType",h={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},f=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=p(t),c=r,m=d["".concat(o,".").concat(c)]||d[c]||h[c]||i;return t?a.createElement(m,s(s({ref:n},u),{},{components:t})):a.createElement(m,s({ref:n},u))}));function x(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=f;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[m]="string"==typeof e?e:r,o[1]=s;for(var u=2;u<i;u++)o[u]=t[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}f.displayName="MDXCreateElement"},59519:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>u});var a=t(87462),r=(t(67294),t(3905));const i={id:"bxl_basics",title:"BXL Basics"},o=void 0,s={unversionedId:"developers/bxl_basics",id:"developers/bxl_basics",title:"BXL Basics",description:"This page is a primer on common BXL functionalities and data types. Ramping up",source:"@site/../docs/developers/bxl_basics.md",sourceDirName:"developers",slug:"/developers/bxl_basics",permalink:"/docs/developers/bxl_basics",draft:!1,tags:[],version:"current",frontMatter:{id:"bxl_basics",title:"BXL Basics"},sidebar:"manualSidebar",previous:{title:"Getting Started",permalink:"/docs/developers/bxl_getting_started"},next:{title:"Common How-Tos",permalink:"/docs/developers/bxl_how_tos"}},l={},u=[{value:"Common BXL functionalities",id:"common-bxl-functionalities",level:2},{value:"Build",id:"build",level:3},{value:"Analysis",id:"analysis",level:3},{value:"Query",id:"query",level:3},{value:"Uquery",id:"uquery",level:4},{value:"Cquery",id:"cquery",level:4},{value:"Aquery",id:"aquery",level:4},{value:"Actions",id:"actions",level:3},{value:"Ensure",id:"ensure",level:3}],d={toc:u};function p(e){let{components:n,...t}=e;return(0,r.mdx)("wrapper",(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,r.mdx)("p",null,"This page is a primer on common BXL functionalities and data types. Ramping up\nin BXL may be challenging without much prior knowledge of Buck2 building blocks\n(ex: targets, configurations, queries), so please take a look at the\n",(0,r.mdx)("a",{parentName:"p",href:"/docs/concepts/concept_map"},"Concepts")," documentation before reading on."),(0,r.mdx)("h2",{id:"common-bxl-functionalities"},"Common BXL functionalities"),(0,r.mdx)("h3",{id:"build"},"Build"),(0,r.mdx)("p",null,"You can build targets within BXL with\n",(0,r.mdx)("a",{parentName:"p",href:"../../api/bxl/bxl_ctx/#bxl_ctxbuild"},(0,r.mdx)("inlineCode",{parentName:"a"},"ctx.build()")),". The result is a\n",(0,r.mdx)("a",{parentName:"p",href:"../../api/bxl/bxl_build_result"},(0,r.mdx)("inlineCode",{parentName:"a"},"bxl_build_result")),", which has ",(0,r.mdx)("inlineCode",{parentName:"p"},"artifacts()"),"\nand ",(0,r.mdx)("inlineCode",{parentName:"p"},"failures()")," functions that provide iterators to the artifacts or failures,\nrespectively. You can pass in a single target or target pattern to build."),(0,r.mdx)("h3",{id:"analysis"},"Analysis"),(0,r.mdx)("p",null,"You can run analysis on targets within BXL via\n",(0,r.mdx)("a",{parentName:"p",href:"../../api/bxl/bxl_ctx/#bxl_ctxanalysis"},(0,r.mdx)("inlineCode",{parentName:"a"},"ctx.analysis()")),". Analysis means to\nevaluate the underlying rule implementation for the inputted targets, and\nproduce the providers that the rule defined for the target. A common workflow is\nto inspect the resulting providers, and perhaps ensure parts of these providers\nor run actions using information from the providers (see ",(0,r.mdx)("a",{parentName:"p",href:"#actions"},"Actions"),"\nbelow)."),(0,r.mdx)("h3",{id:"query"},"Query"),(0,r.mdx)("p",null,"Buck2 supports a couple different query types: querying the unconfigured graph\n(",(0,r.mdx)("inlineCode",{parentName:"p"},"buck2 uquery"),"), the configured graph (",(0,r.mdx)("inlineCode",{parentName:"p"},"buck2 cquery"),"), or the action graph\n(",(0,r.mdx)("inlineCode",{parentName:"p"},"buck2 aquery"),"). These queries are all available in BXL as well:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"ctx.uquery()")," returns a ",(0,r.mdx)("a",{parentName:"li",href:"../../api/bxl/uqueryctx"},(0,r.mdx)("inlineCode",{parentName:"a"},"uqueryctx"))),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"ctx.cquery()")," returns a ",(0,r.mdx)("a",{parentName:"li",href:"../../api/bxl/cqueryctx"},(0,r.mdx)("inlineCode",{parentName:"a"},"cqueryctx"))),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"ctx.aquery()")," returns a ",(0,r.mdx)("a",{parentName:"li",href:"../../api/bxl/aqueryctx"},(0,r.mdx)("inlineCode",{parentName:"a"},"aqueryctx")))),(0,r.mdx)("p",null,"You can read more about the individual queries in the API docs. There are many\nqueries that are common between uquery, cquery, and aquery, but cquery and\naquery will have extra queries unique to the configured graph or the action\ngraph. One more thing to call out is the ",(0,r.mdx)("inlineCode",{parentName:"p"},"eval()")," query, which is a special\nquery that takes in the entire query as a string literal. A common use for\n",(0,r.mdx)("inlineCode",{parentName:"p"},"eval()")," is to migrate a complex query from Buck2 CLI to BXL by dropping the\nentire query string directly into ",(0,r.mdx)("inlineCode",{parentName:"p"},"eval()"),"."),(0,r.mdx)("p",null,"The query results are target sets (iterable container) of\n",(0,r.mdx)("a",{parentName:"p",href:"../../api/bxl/unconfigured_target_node"},(0,r.mdx)("inlineCode",{parentName:"a"},"unconfigured_target_node"),"s")," for\nuquery, ",(0,r.mdx)("a",{parentName:"p",href:"../../api/bxl/target_node"},(0,r.mdx)("inlineCode",{parentName:"a"},"target_node"),"s")," for cquery, and\n",(0,r.mdx)("a",{parentName:"p",href:"../../api/bxl/action_query_node"},(0,r.mdx)("inlineCode",{parentName:"a"},"action_query_node"),"s")," for aquery. Each of\nthese node types have accessors on their attributes. A common workflow is to run\nsome query in BXL, and iterate through the resulting nodes to inspect their\nattributes, and use those attributes to inform further computations in BXL."),(0,r.mdx)("h4",{id:"uquery"},"Uquery"),(0,r.mdx)("p",null,"Querying the unconfigured graph means that no configurations (such as platforms\nand transitions) have been applied to the target graph yet. This means that it's\nvery possible that some parts of the target graph is broken due to lack of\nconfigurations. Generally to avoid this problem, cquery may be preferred\ninstead."),(0,r.mdx)("h4",{id:"cquery"},"Cquery"),(0,r.mdx)("p",null,"Querying the configured graph means that configurations have been applied to the\ntarget graph. For cquery, we require that users use a\n",(0,r.mdx)("a",{parentName:"p",href:"/docs/developers/target_universe"},"target universe")," for their query inputs."),(0,r.mdx)("h4",{id:"aquery"},"Aquery"),(0,r.mdx)("p",null,"Aquery is a quite different from uquery and cquery. It is used to query the\naction graph, which is constructed after Buck2 runs analysis on the targets and\nproduces the list of providers and actions needed to build the target."),(0,r.mdx)("h3",{id:"actions"},"Actions"),(0,r.mdx)("p",null,"You can create actions directly within the BXL API. The available action APIs\nare equivalent to the ones found on the ",(0,r.mdx)("a",{parentName:"p",href:"../../api/bxl/actions"},(0,r.mdx)("inlineCode",{parentName:"a"},"actions"))," type\nfor normal rules, with the caveat that\n",(0,r.mdx)("a",{parentName:"p",href:"/docs/developers/dynamic_output"},"dynamic actions")," use the\n",(0,r.mdx)("a",{parentName:"p",href:"../../api/bxl/bxl_ctx"},(0,r.mdx)("inlineCode",{parentName:"a"},"bxl_ctx"))," (which provides richer functionalities)."),(0,r.mdx)("p",null,"A common workflow would be to run analysis on a target, and use some interesting\nbits found in the analysis result to construct an augmented\n",(0,r.mdx)("a",{parentName:"p",href:"../../api/bxl/cmd_args"},(0,r.mdx)("inlineCode",{parentName:"a"},"cmd_args"))," to run, and then ensure the action's output\n(see below for ensuring). Also see\n",(0,r.mdx)("a",{parentName:"p",href:"/docs/developers/bxl_how_tos#running-actions"},"Running actions"),"."),(0,r.mdx)("h3",{id:"ensure"},"Ensure"),(0,r.mdx)("p",null,"Ensuring an artifact means that you want the artifact to be materialized\n(meaning, downloaded to your machine) at the end of the BXL execution. There are\ntwo APIs for ensuring: ",(0,r.mdx)("inlineCode",{parentName:"p"},"ctx.output.ensure()")," and ",(0,r.mdx)("inlineCode",{parentName:"p"},"ctx.output.ensure_multiple()"),"\n(see ",(0,r.mdx)("a",{parentName:"p",href:"../../api/bxl/bxl_output_stream"},(0,r.mdx)("inlineCode",{parentName:"a"},"bxl_output_stream")),"). As the naming\nindicates, the former is for ensuring a single artifact, and the latter is for\nensuring multiple artifact-like inputs. Artifact-like inputs include\n",(0,r.mdx)("a",{parentName:"p",href:"../../api/bxl/cmd_args"},(0,r.mdx)("inlineCode",{parentName:"a"},"cmd_args"))," (can be found when inspecting providers),\n",(0,r.mdx)("a",{parentName:"p",href:"../../api/bxl/bxl_build_result"},(0,r.mdx)("inlineCode",{parentName:"a"},"bxl_build_result"))," (produced when building\nsomething in BXL), or ",(0,r.mdx)("a",{parentName:"p",href:"../../api/bxl/artifact"},(0,r.mdx)("inlineCode",{parentName:"a"},"artifact"))," (can be found when\ninspecting providers, or creating your own actions)."),(0,r.mdx)("p",null,"A common workflow is to ensure an artifact that you created via some custom\nactions defined in your script, or ensuring some artifacts found in the\nproviders after running analysis. Also see\n",(0,r.mdx)("a",{parentName:"p",href:"/docs/developers/bxl_faqs#what-do-i-need-to-know-about-ensured-artifacts"},"What do I need to know about ensured artifacts"),"."))}p.isMDXComponent=!0}}]);